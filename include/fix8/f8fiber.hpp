//-----------------------------------------------------------------------------------------
// f8_fiber based on boost::fiber, x86_64 / linux only / de-boosted
// Modifications Copyright (C) 2022 Fix8 Market Technologies Pty Ltd
//
// fcontext_t, jump_fcontext, make_fcontext, ontop_fcontext
//	create_fcontext_stack, destroy_fcontext_stack, boost::fiber
//          Copyright Oliver Kowalke 2013.
//
// Distributed under the Boost Software License, Version 1.0 August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------------------
#ifndef FIX8PRO_FIBER_HPP_
#define FIX8PRO_FIBER_HPP_

#include <utility>
#include <functional>
#include <iostream>

//-----------------------------------------------------------------------------------------
namespace FIX8 {

//-----------------------------------------------------------------------------------------
using fcontext_t = void *;
struct fcontext_transfer_t
{
	fcontext_t ctx;
	void *data;
};

struct fcontext_stack_t
{
	void *sptr;
	size_t ssize;
};

fcontext_stack_t create_fcontext_stack(size_t size);
void destroy_fcontext_stack(fcontext_stack_t& s);

extern "C"
{
	/**
	* Switches to another context
	* @param to Target context to switch to
	* @param vp Custom user pointer to pass to new context
	*/
	fcontext_transfer_t jump_fcontext(const fcontext_t to, void *vp);

	/**
	* Make a new context
	* @param sp Pointer to allocated stack memory
	* @param size Stack memory size
	* @param fn Callback function for context (coroutine)
	*/
	fcontext_t make_fcontext(void *sp, size_t size, void (*fn)(fcontext_transfer_t));

	/**
	* @param to fcontext to jump to
	* @param vp data to be transferred
	* @param fn ontop-function
	*/
	fcontext_transfer_t ontop_fcontext(const fcontext_t to, void *vp, fcontext_transfer_t (*fn)(fcontext_transfer_t));
}

//-----------------------------------------------------------------------------------------
struct forced_unwind
{
	fcontext_t fctx{};
	forced_unwind() = default;
	forced_unwind(fcontext_t fctx_) : fctx(fctx_) {}
};

inline fcontext_transfer_t fiber_unwind(fcontext_transfer_t t)
{
	throw forced_unwind(t.ctx);
	return {};
}

template<typename Rec>
fcontext_transfer_t fiber_exit(fcontext_transfer_t t) noexcept
{
	//std::cout << "fiber_exit\n";
	// destroy context stack
	static_cast<Rec *>(t.data)->deallocate();
	return {};
}

template<typename Rec>
void fiber_entry(fcontext_transfer_t t) noexcept
{
	// transfer control structure to the context-stack
	Rec *rec { static_cast<Rec *>(t.data) };
	try
	{
		// jump back to `create_context()`
		t = jump_fcontext(t.ctx, nullptr);
		// start executing
		t.ctx = rec->run(t.ctx);
	}
	catch (const forced_unwind& e)
	{
		t = { e.fctx, nullptr };
	}
	// destroy context-stack of `this`context on next context
	ontop_fcontext(t.ctx, rec, fiber_exit<Rec>);
}

template<typename Ctx, typename Fn>
fcontext_transfer_t fiber_ontop(fcontext_transfer_t t)
{
    auto p { *static_cast<Fn *>(t.data) };
    t.data = nullptr;
    // execute function, pass fiber via reference
    Ctx c { p(Ctx{t.ctx}) };
    return { std::exchange(c.fctx_, nullptr), nullptr };
}

template<typename Rec, typename Fn>
fcontext_t create_fiber(Fn&& fn, size_t stacksz)
{
	auto sctx { create_fcontext_stack(stacksz) };
	// reserve space for control structure
	const fcontext_t fctx { make_fcontext(sctx.sptr, sctx.ssize, &fiber_entry<Rec>) };
	// transfer control structure to context-stack
	return jump_fcontext(fctx, new Rec{ sctx, std::forward<Fn>(fn) }).ctx;
}

//-----------------------------------------------------------------------------------------
template<typename Ctx, typename Fn>
class f8_fiber_record
{
	fcontext_stack_t _stack;
	typename std::decay<Fn>::type _fn;

	static void destroy(f8_fiber_record *p)
	{
		destroy_fcontext_stack(p->_stack);
		delete p;
	}

public:
	f8_fiber_record(fcontext_stack_t sctx, Fn&& fn) noexcept :
		_stack(sctx), _fn(std::forward<Fn>(fn)) {}
	f8_fiber_record(const f8_fiber_record&) = delete;
	f8_fiber_record& operator=(const f8_fiber_record&) = delete;
	~f8_fiber_record() = default;

	void deallocate() noexcept { destroy(this); }

	fcontext_t run(fcontext_t fctx)
	{
		// invoke context-function
		Ctx c { std::invoke(_fn, std::move(Ctx{fctx})) };
		return std::exchange(c.fctx_, nullptr);
	}
};

//-----------------------------------------------------------------------------------------
class f8_fiber
{
	template<typename Ctx, typename Fn>
	friend class f8_fiber_record;
	template<typename Ctx, typename Fn>
	friend fcontext_transfer_t fiber_ontop(fcontext_transfer_t);

	fcontext_t fctx_{ nullptr };

	f8_fiber(fcontext_t fctx) noexcept : fctx_{ fctx } {}

public:
	f8_fiber() noexcept = default;

	template<typename Fn>
	f8_fiber(Fn&& fn, size_t stacksz=8*1024*1024)
		: fctx_ { create_fiber<f8_fiber_record<f8_fiber, Fn>>(std::forward<Fn>(fn), stacksz) } {}

	virtual ~f8_fiber()
	{
		if (fctx_ != nullptr)
			ontop_fcontext(std::exchange(fctx_, nullptr), nullptr, fiber_unwind);
	}

	f8_fiber(f8_fiber&& other) noexcept { swap(other); }
	f8_fiber& operator=(f8_fiber&& other) noexcept
	{
		if (this != &other)
		{
			f8_fiber tmp { std::move(other) };
			swap(tmp);
		}
		return *this;
	}

	f8_fiber(const f8_fiber& other) noexcept = delete;
	f8_fiber& operator=(const f8_fiber& other) noexcept = delete;

	f8_fiber resume() && noexcept { return { jump_fcontext(std::exchange(fctx_, nullptr), nullptr).ctx }; }
	f8_fiber resume() & noexcept { return std::move(*this).resume(); }
	static void resume(f8_fiber&& what) noexcept
	{
		if (what)
			what = std::move(std::move(what).resume());
	}
	static void resume(f8_fiber& what) noexcept
	{
		if (what)
			what = std::move(what.resume());
	}

	template<typename Fn>
	f8_fiber resume_with(Fn&& fn) &&
	{
		auto p { std::forward<Fn>(fn) };
		return { ontop_fcontext(std::exchange(fctx_, nullptr), &p, fiber_ontop<f8_fiber, decltype(p)>).ctx };
	}

	explicit operator bool() const noexcept { return fctx_ != nullptr; }
	bool operator! () const noexcept { return fctx_ == nullptr; }
	bool operator< (const f8_fiber& other) const noexcept { return fctx_ < other.fctx_; }

	void swap(f8_fiber& other) noexcept { std::swap(fctx_, other.fctx_); }

	template<typename charT, class traitsT>
	friend std::basic_ostream<charT, traitsT>& operator<<(std::basic_ostream<charT, traitsT>& os, const f8_fiber& other)
	{
		if (other.fctx_ != nullptr)
			return os << other.fctx_;
		return os << "{not-a-context}";
	}

	class id
	{
		const fcontext_t impl_{ nullptr };

	public:
		id() = default;
		explicit id(const fcontext_t impl) noexcept : impl_{ impl } {}

#if __cplusplus >= 202002L
		auto operator<=>(const id& other) const noexcept { return impl_ <=> other.impl_; }
#else
		bool operator==(const id& other) const noexcept { return impl_ == other.impl_; }
		bool operator!=(const id& other) const noexcept { return impl_ != other.impl_; }
		bool operator<(const id& other) const noexcept { return impl_ < other.impl_; }
		bool operator>(const id& other) const noexcept { return other.impl_ < impl_; }
		bool operator<=(const id& other) const noexcept { return !(*this > other); }
		bool operator>=(const id& other) const noexcept { return !(*this < other); }
#endif

		template<typename charT, class traitsT>
		friend std::basic_ostream<charT, traitsT>& operator<<(std::basic_ostream<charT, traitsT>& os, const id& other)
		{
			if (other.impl_ != nullptr)
				return os << other.impl_;
			return os << "{not-valid}";
		}

		explicit operator bool() const noexcept { return impl_ != nullptr; }
		bool operator! () const noexcept { return impl_ == nullptr; }
	};

	friend f8_fiber::id;
	f8_fiber::id get_id() const noexcept { return id(fctx_); }
};

inline void swap(f8_fiber& l, f8_fiber& r) noexcept { l.swap(r); }

//-----------------------------------------------------------------------------------------
} // namespace FIX8

#endif // FIX8PRO_FIBER_HPP_

